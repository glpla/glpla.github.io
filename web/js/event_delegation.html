<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>事件代理 delegation</title>
  <link rel="stylesheet" href="../../css/common.css">
  <base target="_blank">
  <style>
    .cursor {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: 1px solid #f40;
      pointer-events: none;
      z-index: 99;
      pointer-events: none;
    }

    .cursor::after {
      content: '';
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 10px;
      height: 10px;
      background-color: #f40;
      border-radius: 50%;
    }

    .rating {
      display: flex;
      justify-content: center;
    }

    .rating .iconfont {
      font-size: 2rem;
      color: #999;
    }

    .rating .active {
      color: #f40;
    }

    #txt {
      text-align: center;
      font-size: 2rem;
    }

    .move {
      position: absolute;
      width: 100px;
      height: 60px;
      background-color: #f40;
      z-index: 100;
    }

    @media screen and (max-width:768px) {

      .cursor {
        display: none;
      }
    }

    .box {
      position: relative;
      height: 400px;
      background-color: #f40;
      overflow: hidden;
    }

    .img {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: 2px solid #ff0;
    }
  </style>
</head>

<body>
  <header>
    <h1>事件代理</h1>
    <span>&commat;delegation</span>
  </header>
  <dl>
    <dd><a href="https://stackoverflow.com/questions/1687296/what-is-dom-event-delegation" class="link">Event
        Delegation</a></dd>
    <dt>事件代理</dt>
    <dd>任何一个子元素都可以响应父元素的事件；利用这个特性可以让父元素作为各个子元素的代理</dd>
    <dd>单击outer，事件对象target是outer；没有冒泡，所以响应对象currentTarget也是outer</dd>
    <dd>单击&lt;p&gt;，事件对象target是&lt;p&gt;；然后冒泡到outer，所以响应对象currentTarget是outer</dd>
    <dd>同理，单击&lt;span&gt;，事件对象target是&lt;span&gt;；然后冒泡到outer，所以响应对象currentTarget是outer</dd>
    <dd class="code">
      <pre>
&lt;div class="outer" @click="doOut"&gt;
&lt;p class="inner"&gt;1111&lt;/p&gt;
&lt;span class="inner"&gt;2222&lt;/span&gt;
&lt;/div&gt;</pre>
    </dd>
    <dd>通过判断target来确定单击了哪个子元素；可以根据子元素的标签名（大写）或自定义数据data-判断</dd>
    <dd class="code">
      <pre>
const doOut = (e) => {
  console.log(e.target.tagName);
  console.log(e.target.dataset.id);
  console.log(e.target.innerHTML);
}</pre>
    </dd>
    <dt>应用</dt>
    <dd>.需求：单击标签页，显示对应的内容</dd>
    <dd class="code">
      <pre>
&lt;ul&gt;
  &lt;li&gt;Lorem.&lt;/li&gt;
  &lt;li&gt;Magni.&lt;/li&gt;
  &lt;li&gt;Nihil.&lt;/li&gt;
  &lt;li&gt;Id?&lt;/li&gt;
  &lt;li&gt;Ipsa!&lt;/li&gt;
  &lt;li&gt;Earum?&lt;/li&gt;
  &lt;li&gt;Laboriosam.&lt;/li&gt;
  &lt;li&gt;Voluptatum?&lt;/li&gt;
  &lt;li&gt;Veniam.&lt;/li&gt;
  &lt;li&gt;Aliquid.&lt;/li&gt;
&lt;/ul&gt;
      </pre>
    </dd>
    <dd>.默认方式 - 遍历所有子元素并绑定事件</dd>
    <dd class="code">
      <pre>
let ul = document.querySelector('ul');
let lis = ul.querySelectorAll('li');
lis.forEach(li => {
  li.addEventListener('click', () => {
    console.log(li.innerHTML);
  })
})</pre>
    </dd>
    <dd>.委托：不给直接给元素指定事件，而是给其共同的祖先元素指定事件，通过冒泡机制，根据事件对象target确定目标元素</dd>
    <dd>.通常通过标签名tagName来判断事件对象；该属性并没有直接显示在事件对象e中</dd>
    <dd>.为了唯一标识当前事件对象，可以在渲染的时候通过data-属性和对象绑定</dd>
    <dd>.适合子元素多，且动态变化的情况</dd>
    <dd>.事件委托方式-仅仅给父级元素指定事件</dd>
    <dd class="code">
      <pre>
let ul = document.querySelector('ul');
ul.addEventListener('click', (e) => {
  console.log(e.target.tagName);
  if(e.target.tagName==='LI'){
    //do
  }
})</pre>
    </dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>] 单元素自定义数据data-的获取</dd>
    <dd>.事件对象e和事件目标target是同一个，可以使用属性获取，也可以使用事件目标target获取</dd>
    <dd>.注意函数fn的封装</dd>
    <dd>[HTML]</dd>
    <dd class="code">
      <pre>&lt;div class="tmp" data-id="1001"&gt;单元素自定义数据的获取&lt;/div></pre>
    </dd>
    <dd>[JavaScript]</dd>
    <dd class="code">
      <pre>
let el = document.querySelector('.tmp');
el.onclick = fn;
el.addEventListener('click', fn)
function fn(e) {
    console.log(this.getAttribute('data-id'));
    console.log(e.target.dataset.id);
}</pre>
    </dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>] 父元素自定义数据data-的获取</dd>
    <dd>.多个元素存在，data-数据在父级元素</dd>
    <dd>.事件目标通常是子元素，如果使用dataset，就会导致自定义数据获取失败；只能使用this来获取属性</dd>
    <dd>[HTML]</dd>
    <dd class="code">
      <pre>
&lt;div class="tmp" data-id="1001"&gt;
    &lt;div&gt;child&lt;/div&gt;
    &lt;div&gt;child&lt;/div&gt;
&lt;/div&gt;</pre>
    </dd>
    <dd>.使用同样的js，则第2个log是undefined。因为事件目标是子元素，它没有对应的自定义数据</dd>
    <dd class="mt2">[ <span class="iconfont icon-bell"></span> ] 破解方案</dd>
    <dd>方案1. 判断目标是否是当前标签[要采用大写形式]，如果不是，就查找其父元素；直到找到最外层的父级；也可以用根据当前目标是否有某个属性判断</dd>
    <dd class="code">
      <pre>
function fn(e) {
    console.log(this.getAttribute('data-id'));
    let tar = e.target
    while (tar.nodeName != 'DIV') {
        tar = tar.parentNode
    }
    console.log(tar.dataset.id);
}</pre>
    </dd>
    <dd>方案2. 取消父级所有后代的事件响应，只保留父元素的事件行为，所以事件目标一定就是父元素；简单粗暴</dd>
    <dd class="code">
      <pre>
.tmp * {
    pointer-events: none;
}</pre>
    </dd>
  </dl>
  <iframe src="../../common/footer.html" frameborder="0" scrolling="no" title="footer" id="footer"></iframe>
</body>

</html>