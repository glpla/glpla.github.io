<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>页面事件 - Browser Object Model</title>
  <link rel="stylesheet" href="../../css/common.css">
  <style>
    .back2top {
      position: fixed;
      right: calc((100% - 1000px)/2);
      top: 50%;
      transform: translateY(-50%);
      width: 50px;
      height: 50px;
      border-radius: 4px;
      opacity: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
      text-decoration: none;
    }

    .active {
      animation: show 0.5s linear forwards;
      pointer-events: initial;
    }

    @keyframes show {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }
  </style>
</head>

<body>
  <header>
    <h1>页面事件</h1>
  </header>
  <dl>
    <dd>
      <table>
        <caption>window页面的相关事件</caption>
        <tr>
          <th>类别</th>
          <th>说明</th>
        </tr>
        <tr>
          <td>onload/load</td>
          <td>页面加载完毕，可以获取元素</td>
        </tr>
        <tr>
          <td>onresize/resize</td>
          <td>页面缩放</td>
        </tr>
        <tr>
          <td>onscroll/scroll</td>
          <td>页面滚动</td>
        </tr>
        <tr>
          <td>onscrollend/scrollend</td>
          <td>页面滚动结束</td>
        </tr>
        <tr>
          <td>matchMedia</td>
          <td>媒体查询</td>
        </tr>
      </table>
    </dd>
    <dt>加载完毕 onload</dt>
    <dd>
      <div>.为了保证JS执行时，相关的元素已经准备完毕，JS代码通常写在&lt;body&gt;最后面。如果使用 onload 就可以把代码放在任何地方</div>
      <div>.如果加载内容过多，onload 会占用更多时间，影响用户体验。可以采用 DOMContentLoaded方法。只要 DOM 框架出来即可，不需要渲染CSS/FLASH/图片，且不影响交互</div>
      <div>.如果两个事件都定义了，则先执行 DOMContentLoaded 再执行 onload</div>
      <pre>
window.onload = function () { 
    //... ...
}</pre>
      <pre>
window.addEventListener('DOMContentLoaded', () => { 
    //... ...
})</pre>
    </dd>
    <dt>窗口缩放 onresize</dt>
    <dd>
      <div>.窗口尺寸/大小发生变化触发事件</div>
      <div>.响应式布局经常用到</div>
      <pre>
window.addEventListener('resize', () => {
    //... ...
})</pre>
    </dd>
    <dd>[<span class="iconfont icon-keyboard"></span>] 动态调整字体大小</dd>
    <dd>
      <div>.20是选定的参考字体大小；通常选择16px，可以根据需要调整</div>
      <div>.320是选定的设备宽度，通常参照苹果某个型号，如iPhone6/7/8是375px</div>
      <div>.40是最大字号</div>
      <div>.如果使用16px、375px，检查元素并使用iPhone6/7/8，发现HTML字体大小被动态设置为16px</div>
      <div>.以下代码要放到 &lt;head&gt;，优先执行</div>
      <pre>
&lt;script&gt;
  let setFontSize = () => {
    let w = document.documentElement.clientWidth;
    let size = (20 * (w / 320) > 40 ? 40 + 'px' : (20 * (w / 320) + 'px'))
    document.documentElement.style.fontSize = size;
  }
  window.addEventListener('load', setFontSize)
  window.addEventListener('resize', setFontSize)
&lt;/script&gt;</pre>
    </dd>
    <dt>窗口滚动 onscroll</dt>
    <dd>.只有当出现滚动条时，scroll 事件才会触发</dd>
    <dd>.利用 DOM 的 scrollTop 或 window 的 scrollY 进行特别的设计，如调整字体大小、延时出现返回顶部按钮、调整导航条样式等等</dd>
    <dd>.更多信息，请访问 <a href="./scroll.html">滚动 - scroll</a></dd>
    <dd>[<span class="iconfont icon-keyboard"></span>] 返回顶部按钮</dd>
    <dd>
      <a class="back2top" href="#el"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 32 32">
          <path fill="#ea580c"
            d="m7.715 10.44l7.57-8.13a.992.992 0 0 1 1.43-.01l7.57 8.13c.56.596.12 1.563-.71 1.563h-3.64c-.35 0-.64.284-.64.625v5.195c0 .645-.53 1.163-1.19 1.163h-4.22c-.65 0-1.19-.518-1.18-1.153v-5.195a.637.637 0 0 0-.64-.625h-3.64c-.83 0-1.27-.958-.71-1.564m4.725 10.379H6c-.55 0-1 .45-1 1s.45 1 1 1h2.22v6.17c0 .55.45 1 1 1s1-.45 1-1v-6.17h2.22c.55 0 1-.45 1-1c0-.56-.45-1-1-1m9.39.01h2.77c1.51 0 2.74 1.23 2.74 2.74c0 1.51-1.23 2.74-2.74 2.74h-1.77v2.69c0 .55-.45 1-1 1s-1-.45-1-1v-7.17c0-.55.45-1 1-1m1 3.48h1.77c.41 0 .74-.33.74-.74s-.33-.74-.74-.74h-1.77zm-9.39 2.55c0 1.73 1.41 3.14 3.15 3.14c1.73 0 3.15-1.41 3.15-3.14v-2.88c0-1.73-1.41-3.14-3.15-3.14s-3.15 1.41-3.15 3.14zm2-2.88a1.15 1.15 0 0 1 2.3 0v2.88c0 .64-.52 1.15-1.15 1.15c-.63 0-1.15-.52-1.15-1.15z" />
        </svg></a>
    </dd>
    <dd>
      <div>.分别利用DOM的scrollTop和window的scrollY查看页面滚动</div>
      <div>.页面位于顶端时，返回按钮不出现，且取消事件响应</div>
      <div>.当页面滚动到一定位置，如一个窗口内部高度时，返回按钮出现，可以响应事件，点击可以返回顶部</div>
      <div>.添加帧动画，使返回按钮的出现更顺滑</div>
      <div>.还可以使用window的pageYOffset、innerHeight属性判断</div>
      <pre>
window.addEventListener('scroll', () => {    
    back2top.classList.toggle('active', scrollY > innerHeight)
})</pre>
    </dd>
    <dd>[<span class="iconfont icon-keyboard"></span>] 页面滚动禁止</dd>
    <dd>
      <div>.移动端弹出菜单时，通常应禁止页面继续滚动；如汉堡菜单#ham点击时，出现顶层菜单，下方的页面不应该再响应事件和滚动</div>
      <div>再次单击，顶层菜单消失，下方页面恢复正常；通过汉堡菜单的单击，切换页面的隐藏类</div>
      <pre>
.hidden {
    overflow: hidden;
}</pre>
      <pre>
ham.addEventListener('click', function () {
    //... ...
    document.body.classList.toggle('hidden')
})</pre>
    </dd>
    <dt>响应媒体查询 matchMedia</dt>
    <dd>
      <div>检测当前浏览器窗口是否匹配某个CSS媒体查询的函数</div>
      <div>返回一个 MediaQueryList 对象；该对象包含一个 matches 属性，表示媒体查询是否与当前窗口大小匹配</div>
      <div>可以通过监听 MediaQueryList 对象的 change 事件来响应窗口大小的变化，或者直接检查 matches 属性来获取当前状态</div>
      <div>定义媒体查询</div>
      <pre>let mediaQuery = window.matchMedia("(max-width: 768px)");</pre>
      <div>监听媒体查询的变化</div>
      <pre>mediaQuery.addListener(handleMediaChange);</pre>
      <div>自定义处理函数</div>
      <pre>
function handleMediaChange(e){
  if (e.matches) {
    // less than or equal to 768px
    // 媒体查询匹配
  } else {
    // wider than 768px
    // 媒体查询不匹配
  }
}</pre>
    </dd>
  </dl>
  <iframe src="../../common/footer.html" frameborder="0" scrolling="no" title="footer" id="footer"></iframe>
  <script>
    // scroll
    let back2top = document.querySelector('.back2top')
    window.addEventListener('scroll', () => {
      // let stop = document.documentElement.scrollTop || document.body.scrollTop;
      // console.log('scrollTop', stop.toFixed(0));
      // console.log('scrollY', window.scrollY.toFixed(0));
      // console.log('pageYOffset', window.pageYOffset.toFixed(0));
      back2top.classList.toggle('active', scrollY > innerHeight)
    })
    // mediaQuery
    let mediaQuery = window.matchMedia("(max-width: 768px)");
    mediaQuery.addListener(handleMediaChange);
    function handleMediaChange(e) {
      if (e.matches) {
        // less than or equal to 768px
        console.log('媒体查询匹配');
      } else {
        // wider than 768px
        console.log('媒体查询不匹配');
      }
    }
  </script>
</body>

</html>