<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>事件 Event</title>
  <link rel="stylesheet" href="../css/styleNew.css">
  <base target="_blank">
  <style>
    .cursor {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: 1px solid #f40;
      pointer-events: none;
      z-index: 99;
      pointer-events: none;
    }

    .cursor::after {
      content: '';
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 10px;
      height: 10px;
      background-color: #f40;
      border-radius: 50%;
    }

    .rating {
      display: flex;
      justify-content: center;
    }

    .rating .iconfont {
      font-size: 2rem;
      color: #999;
    }

    .rating .active {
      color: #f40;
    }

    #txt {
      text-align: center;
      font-size: 2rem;
    }

    .move {
      position: absolute;
      width: 100px;
      height: 60px;
      background-color: #f40;
      z-index: 100;
    }

    @media screen and (max-width:768px) {

      .cursor {
        display: none;
      }
    }

    .box {
      position: relative;
      height: 400px;
      background-color: #f40;
      overflow: hidden;
    }

    .img {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: 2px solid #ff0;
    }
  </style>
</head>

<body>
  <header>
    <h1>&commat;Event</h1>
    <span class="ham iconfont icon-menu"></span>
    <ul class="nav">
      <li class="nav-item">概述</li>
      <li class="nav-item">事件侦听</li>
      <li class="nav-item">鼠标事件</li>
      <li class="nav-item">表单事件</li>
      <li class="nav-item">按键事件</li>
      <li class="nav-item">移动端事件</li>
      <li class="nav-item">拖拽事件</li>
      <li class="nav-item">默认事件</li>
    </ul>
  </header>
  <div class="chap">概述 Overview</div>
  <dl class="nav-cont">
    <dd>.三元素：事件对象、事件类型、事件处理函数</dd>
    <dt>事件对象</dt>
    <dd>.事件产生时，由系统自动创建；在事件处理函数中作为形式参数，名字任意，通常使用event、e、evt等语义化名字</dd>
    <dd>
      .事件对象详细节录了事件的类型[冒泡与否]、发生位置[screen、page]、大小[offset、client]、时间timestamp、响应事件的目标元素target等信息；如果有多个元素或多层嵌套，则响应事件的目标元素也不同
    </dd>
    <dd>.还可以利用事件对象e阻止冒泡和阻止默认事件，见后续案例</dd>
    <dd>.如果元素使用了data-自定义数据，应该在目标target的dateset去获取</dd>
    <dt>事件类型</dt>
    <dd>.最常用的就是鼠标事件，如click；还有其它事件类型，如按键事件，见后续内容</dd>
    <dt>事件处理函数 Handler</dt>
    <dd>.处理事件的函数，也叫响应</dd>
    <dd>.多以函数的形式写在脚本中，可以满足多个元素的使用</dd>
    <dd class="mt2">形式1：<span class="warn">元素属性</span>的形式</dt>
    <dd>.以onXXX的形式作为元素的一个属性写在元素上</dd>
    <dd>.只能满足当前元素的需求</dd>
    <dd>.只能处理冒泡阶段</dd>
    <dd>.不符合结构、样式、行为分离原则，较少使用</dd>
    <dd>[<span class="iconfont icon-keyboard"></span>]完全耦合</dd>
    <dd>
      <pre>&lt;div onclick="alert('hi,there.')"&gt;点击我&lt;/div&gt;</pre>
    </dd>
    <dd>[<span class="iconfont icon-keyboard"></span>]部分耦合-结构逻辑分离</dd>
    <dd>
      <pre>&lt;div onclick="fn()"&gt;点击我&lt;/div&gt;</pre>
    </dd>
    <dd>
      <pre>
function fn() {
  alert('hi,there.')
}</pre>
    </dd>
    <dd>[<span class="iconfont icon-keyboard"></span>]部分耦合-携带形参</dd>
    <dd>
      <pre>&lt;div onclick="fn_para({id:1,name:'glpla'})"&gt;点击我&lt;/div&gt;</pre>
    </dd>
    <dd>
      <pre>
function fn_para(p) {
    console.log(this);
    console.log(p);
}</pre>
    </dd>
    <dd class="mt2">形式2：<span class="warn">对象属性</span> 的形式</dt>
    <dd>.先获取对象再以属性的形式分配事件onXXX</dd>
    <dd>.兼容性非常好</dd>
    <dd>.只能满足当前元素；且元素只能绑定一个事件</dd>
    <dd>.需要等页面加载完成onload后才能获取元素</dd>
    <dd>.事件函数可以接受参数；可以使用形参e获取事件对象；可以使用this获取执行事件函数的元素；也可以显式的指明参数</dd>
    <dd>.不方便传递参数</dd>
    <dd>[<span class="iconfont icon-keyboard"></span>]oXXX事件-默认形参this</dd>
    <dd>
      <pre>
window.onload = function () {
    let el = document.querySelector('div')
    el.onclick = function () {
        console.log(this);
    }
}</pre>
    </dd>
    <dd>[<span class="iconfont icon-keyboard"></span>]oXXX事件-事件对象</dd>
    <dd>
      <pre>
window.onload = function () {
    let el = document.querySelector('div')
    el.onclick = function (e) {
        console.log(e);
        console.log(this);
    }
}</pre>
    </dd>
    <dd class="mt2">形式3：<span class="warn">事件侦听addEventListener</span> 的形式-见后续内容</dt>
    <dd class="mt2">其它：<span class="warn">事件绑定AttachEvent</span> ；IE专有；已停服</dt>
    <dt>冒泡事件和捕获事件</dt>
    <dd>.页面接受事件的顺序，即：事件发生时，在元素节点之间按照特定的顺序传播的过程</dd>
    <dd>.三个阶段：捕获阶段 capture phrase → 当前目标阶段 target phrase → 冒泡阶段 bubbling phrase</dd>
    <dd>.当点击页面的一个元素的时候，事件会从这个元素的祖先元素逐层传递下来 - 捕获；当事件传递到这个元素之后 - 目标，触发事件本身的程序内容；然后又会把事件逐层传递回去 - 冒泡，直到根元素为止</dd>
    <dd>.先捕获事件才能处理；事件捕获：网景提出；事件冒泡：微软提出|IE提出</dd>
    <dd>.JS代码只能执行冒泡或捕获中的一个阶段</dd>
    <dd>.事件冒泡是默认行为。这意味着，如果你在一个子元素|组件上绑定了一个事件，当该事件被触发时，它会沿着DOM|组件树向上冒泡，直到到达根节点|根组件</dd>
    <dd>.事件捕获是指当一个元素上的事件被触发时，它会从文档的根节点开始，向下传播，直到到达目标元素</dd>
    <dd>.使用e.stopPropagation|e.cancelBubble可以取消冒泡</dd>
    <dd class="quote">
      <div>stopPropagation和cancelBubble都可以阻止浏览器默认的事件冒泡行为</div>
      <div>cancelBubble方法不符合W3C标准，只支持IE浏览</div>
      <div>stopPropagation符合W3C标准，适用于FireFox等浏览器，不支持IE</div>
    </dd>
    <dt>target currentTarget</dt>
    <dd>target在事件流的目标阶段</dd>
    <dd>currentTarget在事件流的捕获，目标及冒泡阶段。只有当事件流处在目标阶段的时候，两个的指向才是一样的，
      而当处于捕获和冒泡阶段的时候，target指向被单击的对象；currentTarget指向当前事件活动的对象（一般为父级）</dd>
    <dd>.具体细节，请参考后续内容-鼠标事件-实例</dd>
  </dl>
  <div class="chap">事件侦听 addEventListener</div>
  <dl class="nav-cont">
    <dt>说明</dt>
    <dd>.1个元素可以注册多个事件侦听，甚至可以为同一个事件类型指定不同的处理函数</dd>
    <dd>.addEventListener有三个参数：事件类型、处理函数、事件处理方式</dd>
    <dd>.事件处理函数不要采用匿名函数的方式，否则无法解除</dd>
    <dd>.第三个参数事件处理方式默认是false，表示冒泡阶段；如果为true，则为捕获阶段如果上层元素无事件，则没有区别；实际开发中，更关注冒泡，很少使用捕获</dd>
    <dd>.部分事件如：blur/focus/submit/change/reset/select/mouseleave/mouseenter是没有冒泡的</dd>
    <dt>事件注册</dt>
    <dd>
      <pre>
el.addEventListener(事件类型, 处理函数, 事件处理方式)</pre>
    </dd>
    <dt>事件清除</dt>
    <dd>.匿名函数，无法解除</dd>
    <dd>
      <pre>
el.removeEventListener(事件类型, 处理函数, 事件处理方式)</pre>
    </dd>
    <dd>[<span class="iconfont icon-keyboard"></span>]侦听多个事件处理函数</dd>
    <dd>
      <pre>
let div = document.querySelector('div');
div.addEventListener('click', fn0);
div.addEventListener('click', fn1);
function fn0() {
  console.log('fn0');
}
function fn1() {
  console.log('fn1');
}</pre>
    </dd>
    <dt>事件传参</dt>
    <dd>.不能直接使用，否则会被立即执行</dd>
    <dd>.需要使用匿名函数，在匿名函数里执行封装的带参函数</dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>] 封装表单域的获取焦点和失去焦点函数</dd>
    <dd>
      <pre>
function setBg(color) {
  console.log('hi');
  console.log(ta);
  ta.style.background = color;
}</pre>
    </dd>
    <dd>.获取元素并侦听事件，发现函数被立即执行了其中的log，但是元素并没有按照设想改变颜色；继续交互同样不会执行</dd>
    <dd>
      <pre>
ta.addEventListener('focus', setBg('#f40'));
ta.addEventListener('blur', setBg('#ccc'));</pre>
    </dd>
    <dd>.将封装的带参函数，放在匿名函数中执行。问题解决</dd>
    <dd>
      <pre>
ta.addEventListener('focus', function () {
  setBg('#f40')
});
ta.addEventListener('blur', function () {
  setBg('#ccc')
});</pre>
    </dd>
    <dd>.也可以使用箭头函数，同时获取事件对象e</dd>
    <dd>
      <pre>
ta.addEventListener('focus', (e) => {
  console.log(e);
  setBg('#f40')
});
ta.addEventListener('blur', (e) => {
  console.log(e);
  setBg('#ccc')
});</pre>
    </dd>
  </dl>
  <div class="chap">鼠标事件 mouse</div>
  <dl class="nav-cont">
    <dt>鼠标事件类型</dt>
    <dd>
      <table>
        <tr>
          <th>类别</th>
          <th>说明</th>
        </tr>
        <tr>
          <td>click</td>
          <td>特指鼠标左键单击，包括按下并释放</td>
        </tr>
        <tr>
          <td>mouseover</td>
          <td>悬停</td>
        </tr>
        <tr>
          <td>mouseenter</td>
          <td>移入</td>
        </tr>
        <tr>
          <td>mousedown</td>
          <td>按下</td>
        </tr>
        <tr>
          <td>mousemove</td>
          <td>移动</td>
        </tr>
        <tr>
          <td>mouseup</td>
          <td>弹起/释放</td>
        </tr>
        <tr>
          <td>mouseout</td>
          <td>移出</td>
        </tr>
        <tr>
          <td>mouseleave</td>
          <td>离开</td>
        </tr>
        <tr>
          <td>contextmenu</td>
          <td>右键菜单事件</td>
        </tr>
      </table>
    </dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>] 冒泡事件</dd>
    <dd>.三个嵌套盒子的冒泡：利用log分别查看默认冒泡和取消冒泡的情况</dd>
    <dd>[HTML]</dd>
    <dd>
      <pre>
&lt;div class="box1"&gt;box1
  &lt;div class="box2"&gt;box2
    &lt;div class="box3"&gt;box3&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
    </dd>
    <dd>[Javascript]单击里层的元素，事件会逐步冒泡到外层</dd>
    <dd>
      <pre>
let box1 = document.querySelector('.box1')
let box2 = document.querySelector('.box2')
let box3 = document.querySelector('.box3')
box1.addEventListener('click', () => {
  console.log('box1 clicked');
})
box2.addEventListener('click', () => {
  console.log('box2 clicked');
})
box3.addEventListener('click', () => {
  console.log('box3 clicked');
})</pre>
    </dd>
    <dd>[Javascript]借助事件对象e，取消事件冒泡，单击哪个元素，触发哪个元素的事件</dd>
    <dd>
      <pre>
box1.addEventListener('click', (e) => {
  e.stopPropagation();
  console.log('box1 clicked');
})
box2.addEventListener('click', (e) => {
  e.stopPropagation();
  console.log('box2 clicked');
})
box3.addEventListener('click', (e) => {
  e.stopPropagation();
  console.log('box3 clicked');
})</pre>
    </dd>
    <dd>[<span class="iconfont icon-keyboard"></span>] 评分 rating</dd>
    <dd>.iconfont</dd>
    <dd>.click</dd>
    <dd>.forEach</dd>
    <dd>.for</dd>
    <dd class="rating">
      <span class="iconfont icon-iconfontshoucang"></span>
      <span class="iconfont icon-iconfontshoucang"></span>
      <span class="iconfont icon-iconfontshoucang"></span>
      <span class="iconfont icon-iconfontshoucang"></span>
      <span class="iconfont icon-iconfontshoucang"></span>
    </dd>
    <dd id="txt">请打分</dd>
    <dd>
      <pre>
let rate = ['很差', '差', '一般', '好', '很好'];
let wrap = document.querySelector('.rating');
let imgs = wrap.querySelectorAll('span');
let txt = document.querySelector('#txt');
imgs.forEach((img, ind) => {
  img.addEventListener('click', () => {
    imgs.forEach(img => {
      img.classList.remove('active');
    })
    for (let i = 0; i <= ind; i++) {
      imgs[i].classList.add('active');
    }
    txt.innerHTML = rate[ind];
  })
})</pre>
    </dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>] 鼠标跟随/定制鼠标；更多案例，请访问<a
        href="../demo/follow.html">鼠标跟随</a></dd>
    <dd>.元素应脱离文档流 absolute</dd>
    <dd>.通常跟随鼠标在页面上的位置pageY、pageY</dd>
    <dd>.局部范围内可以使用offsetX、offsetY</dd>
    <dd>案例1：全局跟随</dd>
    <dd class="cursor" id="cursor"></dd>
    <dd>
      <pre>
document.addEventListener('mousemove', (e) => {
  cursor.style.left = e.pageX + 'px'
  cursor.style.top = e.pageY + 'px'
})</pre>
    </dd>
    <dd>案例2：局部跟随</dd>
    <div class="box">
      <div class="img"></div>
    </div>
    <dd>[HTML]</dd>
    <dd>
      <pre>
&lt;div class="box"&gt;
  &lt;div class="img"&gt;&lt;/div&gt;
&lt;/div&gt;</pre>
    </dd>
    <dd>[CSS]</dd>
    <dd>
      <pre>
.box {
  position: relative;
  width: 800px;
  height: 600px;
  margin: 100px auto;
  background-color: #f40;
  overflow: hidden;
}

.img {
  position: absolute;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  border: 2px solid #ff0;
}</pre>
    </dd>
    <dd>[JavaScript]</dd>
    <dd>
      <pre>
let box = document.querySelector('.box');
let img = document.querySelector('.img');
box.addEventListener('mousemove', fn);
function fn(e) {
  console.log(e.offsetX, e.offsetY);
  let x = e.pageX - box.offsetLeft - 15;
  let y = e.pageY - box.offsetTop - 15;
  img.style.left = x + 'px';
  img.style.top = y + 'px';
}</pre>
    </dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>] 放大镜</dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>] 单元素自定义数据data-的获取</dd>
    <dd>.事件对象e和事件目标target是同一个，可以使用属性获取，也可以使用事件目标target获取</dd>
    <dd>.注意函数fn的封装</dd>
    <dd>[HTML]</dd>
    <dd>
      <pre>&lt;div class="tmp" data-id="1001"&gt;单元素自定义数据的获取&lt;/div></pre>
    </dd>
    <dd>[JavaScript]</dd>
    <dd>
      <pre>
let el = document.querySelector('.tmp');
el.onclick = fn;
el.addEventListener('click', fn)
function fn(e) {
    console.log(this.getAttribute('data-id'));
    console.log(e.target.dataset.id);
}</pre>
    </dd>
  </dl>
  <div class="chap">表单事件 form</div>
  <dl class="nav-cont" data>
    <dt>表单默认事件</dt>
    <dd>.默认情况下，表单提交时，数据需要提交给后端处理，页面会发生跳转</dd>
    <dd>.前端要拿数据，需要阻止表单的默认行为；类似的还有&lt;a&gt;</dd>
    <dd>.前端拿数据，可以通过元素逐一获取，很不方便；也可以使用form构造的FormData集中获取</dd>
    <dd>
      <pre>&lt;form action=""&gt;&lt;/form&gt;</pre>
    </dd>
    <dd>
      <pre>
form.addEventListener('submit', (e) => {
  e.preventDefault();
})</pre>
    </dd>
    <dd>[或]</dd>
    <dd>
      <pre>
form.addEventListener('submit', () => {
  return false;
})</pre>
    </dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>] 通过元素获取</dd>
    <dd>
      <pre>
input.addEventListener('change', () => {
  console.log(input.value);
})</pre>
    </dd>
    <dt>FormData</dt>
    <dd>FormData(src)：构造函数；需要一个数据源参数，如表单</dd>
    <dd>formdata.append(name, value)：添加</dd>
    <dd>formdata.get(name)：获取属性第一个值</dd>
    <dd>formdata.getAll(name)；获取所有值，返回的是一个数组</dd>
    <dd>formdata.delete(name)：删除属性</dd>
    <dd>[<span class="iconfont icon-bell"></span>]console.log(formdata) 打印出来的结果 始终为FormData {}
      它有一个隐藏域：所有的操作对象的方法全部是在它的原型中</dd>
    <dd>
      <img src="../imgs/formData.png" alt="">
    </dd>
    <dt>获取表单数据</dt>
    <dd>1.提交时构造数据submit</dd>
    <dd>2.数据构造完毕后，提取数据formdata；如果提交后，马上获取，有可能数据还未构造完毕，导致失败</dd>
    <dd>
      <form id="formdata">
        <label>
          <span>name</span>
          <input type="text" name="uname" value="123">
        </label>
        <label>
          <span>pass</span>
          <input type="password" name="upass" value="321">
        </label>
        <textarea name="umsg" value="msg hi there"></textarea>
        <button>submit</button>
      </form>
    </dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>] 数据少的时候，直接获取</dd>
    <dd>
      <pre>
let form = document.querySelector('form');
form.addEventListener('submit', (e) => {
  e.preventDefault();
  new FormData(form);
})
form.addEventListener('formdata', (e) => {
  const data = e.formData;
  console.log(data.get('uname'));
})</pre>
    </dd>
    <dd>甚至可以直接获取</dd>
    <dd>
      <pre>
let form = document.querySelector('form');
let fd = new FormData(form);
console.log(fd);
fd.forEach((val, key) => {
  console.log(val, key);
})</pre>
    </dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>] 数据多的时候，通过遍历获取</dd>
    <dd>
      <pre>
let form = document.querySelector('form');
form.addEventListener('submit', (e) => {
  e.preventDefault();
  new FormData(form);
})
form.addEventListener('formdata', (e) => {
  const data = e.formData;
  for (const value of data.values()) {
    console.log(value);
  }
})</pre>
    </dd>
    <dt>FormData转化为JSON[进阶]</dt>
    <dd>
      <pre>
function FormData2JSON(formdata) {
  var json = {};
  var entries = formdata.entries();
  var item = entries.next();
  console.log(item);

  while (!item.done) {
    json[item.value[0]] = item.value[1];
    item = entries.next();
  }
  return json;
}</pre>
    </dd>
    <dt>将JSON转化为FormData[进阶]</dt>
    <dd>
      <pre>
function JSON2FormData(json) {
  var formdata = new FormData();
  for (let key in json) {
    formdata.append(key, json[key]);
  }
  return formdata;
}</pre>
    </dd>
    <dd>.更多信息，请访问<a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData">FormData</a></dd>
  </dl>
  <div class="chap">键盘事件 key</div>
  <dl class="nav-cont">
    <dd>.执行顺序：keydown→keypress→keyup</dd>
    <dd>.部分事件不能使用侦听，只能使用传统事件onXXX</dd>
    <dt>键盘事件类型</dt>
    <dd>
      <table>
        <tr>
          <th>类别</th>
          <th>说明</th>
        </tr>
        <tr>
          <td>keydown</td>
          <td>按下，不区分大小写</td>
        </tr>
        <tr>
          <td>keyup</td>
          <td>弹起/释放，不区分大小写</td>
        </tr>
        <tr>
          <td>keypress</td>
          <td>按住并保持；区分大小写；不能识别backspace、CTRL、shift、方向键等功能键<br>规范已经不建议使用</td>
        </tr>
      </table>
    </dd>
    <dt>常用属性</dt>
    <dd>
      <table>
        <tr>
          <th>类别</th>
          <th>说明</th>
        </tr>
        <tr>
          <td>e.key</td>
          <td>按键名如，f、F12</td>
        </tr>
        <tr>
          <td>e.keycode</td>
          <td>按键编码|键值|键码；规范中已不建议使用</td>
        </tr>
      </table>
    </dd>
    <dt>常用键名</dt>
    <dd>
      <table>
        <tr>
          <th>类别</th>
          <th>说明</th>
        </tr>
        <tr>
          <td>数字1-9</td>
          <td>1-9</td>
        </tr>
        <tr>
          <td>字母a-zA-Z</td>
          <td>a-zA-Z</td>
        </tr>
        <tr>
          <td>回车</td>
          <td>Enter</td>
        </tr>
        <tr>
          <td>功能键F1-F12</td>
          <td>F1-F12</td>
        </tr>
        <tr>
          <td>上键</td>
          <td>ArrowUp</td>
        </tr>
        <tr>
          <td>下键</td>
          <td>ArrowDown</td>
        </tr>
        <tr>
          <td>左键</td>
          <td>ArrowLeft</td>
        </tr>
        <tr>
          <td>右键</td>
          <td>ArrowRight</td>
        </tr>
        <tr>
          <td>其它</td>
          <td>Escape、Tab、Capslock、Shift、Control、Meta、Alt、Delete、Backspace</td>
        </tr>
        <tr>
          <td>复合键，如shift+8是*</td>
          <td>!、 @、 #、 $、 %、 ^、 &、 *、 (、 )</td>
        </tr>
      </table>
    </dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>] JD搜索优化</dd>
    <dd>.页面任何位置按下s，激活搜索框</dd>
    <dd>
      <pre>
let ipt = document.querySelector('input');
document.addEventListener('keyup', (e) => {
    if (e.key == 83) {
        ipt.focus()
    }
})</pre>
    </dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>] Ctrl+回车，提交信息</dd>
    <dd>如果要使用组合键，则可以利用event.ctrlKey，event.shiftKey，event.altKey判断是否按下了ctrl键、shift键以及alt键</dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>] JD快递单号查询</dd>
    <dd>.为方便阅读，在原搜索框上方额外显示一个字体略大的提示框。失去焦点时，隐藏提示框；获取焦点时，如果内容不为空，则显示提示框</dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>] 禁止F12键</dd>
    <dd>
      <pre>
document.onkeydown = function (e) {
  if (e.key == 'F12') {
    return false;
  }
}</pre>
    </dd>
  </dl>
  <div class="chap">移动端事件 touch</div>
  <dl class="nav-cont">
    <dt>事件类型</dt>
    <dd>
      <table>
        <tr>
          <th>类别</th>
          <th>说明</th>
        </tr>
        <tr>
          <td>touchstart</td>
          <td>开始触摸；触发一次</td>
        </tr>
        <tr>
          <td>touchmove</td>
          <td>触摸并移动；持续触发</td>
        </tr>
        <tr>
          <td>touchend</td>
          <td>触摸结束；触发一次</td>
        </tr>
        <tr>
          <td>touchcancel</td>
          <td>触摸中断</td>
        </tr>
      </table>
    </dd>
    <dt>事件属性</dt>
    <dd>
      <table>
        <tr>
          <th>类别</th>
          <th>说明</th>
        </tr>
        <tr>
          <td>targetTouches</td>
          <td>触摸的手指个数</td>
        </tr>
        <tr>
          <td>changedTouches</td>
          <td>发生改变的触摸的手指个数；通常使用这个属性作为判断的依据</td>
        </tr>
      </table>
    </dd>
    <dt>特点</dt>
    <dd>.优先触发移动端事件[移动优先]，普通单击事件会有延迟：为了判断用户是否要双击，所以第一次单击后，要延迟一定时间[300ms]，等待用户下一次单击。如果有，就是双击，否则判定为单击</dd>
    <dd>.300ms是早期的一个评估值，和硬件设备和用户操作有关系；目前通常在100ms左右</dd>
    <dd>[解决方案]</dd>
    <dd>.使用第三方插件 <a href="https://github.com/ftlabs/fastclick">fastclick</a>；既不影响桌面端使用，也可以在移动端正常使用</dd>
    <dd>.封装touch函数</dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>]事件触发顺序</dd>
    <dd>
      <pre>
let box = document.querySelector('.cont');
let data0, data1;
box.addEventListener('click', () => {
  data1 = new Date();
  console.log(data1 - data0);
  console.log('click');
})
box.addEventListener('touchstart', () => {
  data0 = new Date();
  console.log('touchstart');
})
box.addEventListener('touchend', () => {
  console.log('touchend');
})</pre>
    </dd>
  </dl>
  <div class="chap">拖拽事件 drag</div>
  <dl class="nav-cont">
    <dt>说明</dt>
    <dd>3个事件：分别对应三个阶段</dd>
    <dd class="flex-h">dragenter<span class="dot"></span>拖拽进去</dd>
    <dd class="flex-h">dragover<span class="dot"></span>拖拽悬停</dd>
    <dd class="flex-h">drop<span class="dot"></span>拖拽释放</dd>
    <dd>
      <pre>
let drag = document.querySelector('#drag')
drag.addEventListener('dragenter', function (e) {
    e.stopPropagation();
    e.preventDefault();
})
drag.addEventListener('dragover', function (e) {
    e.stopPropagation();
    e.preventDefault();
})
drag.addEventListener('drop', function (e) {
    e.stopPropagation();
    e.preventDefault();
    console.log(e.dataTransfer.files);
})</pre>
    </dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>] 使用鼠标事件实现拖拽</dd>
    <dd>
      <div class="move"></div>
    </dd>
    <dd>[传统事件方式]</dd>
    <dd>
      <pre>
let move = document.querySelector('.move');
move.onmousedown = function (e) {
  let left = e.clientX - move.offsetLeft;
  let top = e.clientY - move.offsetTop;
  move.onmousemove = function (ev) {
    move.style.left = ev.clientX - left + 'px';
    move.style.top = ev.clientY - top + 'px';
  }
  move.onmouseup = function () {
    move.onmousemove = null;
  }
}</pre>
    </dd>
    <dd>[事件侦听方式]</dd>
    <dd>.为了避免移动速度过快导致鼠标移动到元素外面，给文档mousemove事件和mouseup事件</dd>
    <dd>.限制在当前视口移动：上下左右移动</dd>
    <dd>
      <pre>
move.addEventListener('mousedown', fmd);
move.addEventListener('mouseup', fmu);
let leftPos, topPos;
function fmd(e) {
  leftPos = e.clientX - move.offsetLeft;
  topPos = e.clientY - move.offsetTop;
  document.addEventListener('mousemove', fmm);
}
function fmm(e) {
  let disX = e.clientX - leftPos;
  let disY = e.clientY - topPos;
  if (disX < 0) {
    disX = 0;
  } else if (disX >= document.documentElement.clientWidth - move.offsetWidth) {
    disX = document.documentElement.clientWidth - move.offsetWidth;
  }
  console.log(document.documentElement.clientHeight);
  if (disY < 0) {
    disY = 0;
  } else if (disY > document.documentElement.clientHeight - move.offsetHeight) {
    disY = document.documentElement.clientHeight - move.offsetHeight;
  }
  move.style.left = disX + 'px';
  move.style.top = disY + 'px';
}
function fmu() {
  document.removeEventListener('mousemove', fmm);
}</pre>
    </dd>
  </dl>
  <div class="chap">默认事件 default</div>
  <dl class="nav-cont">
    <dd>1. 右键菜单</dd>
    <dd>2. &lt;form&gt;提交的默认</dd>
    <dd>3. &lt;a&gt;的跳转</dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>] 阻止右键菜单</dd>
    <dd>
      <pre>
document.addEventListener('contextmenu', (e) => {
  e.preventDefault();
})</pre>
    </dd>
    <dd>.或</dd>
    <dd>
      <pre>
document.oncontextmenu = function () {
  return false;
}</pre>
    </dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>] 阻止&lt;form&gt;提交的默认跳转</dd>
    <dd>
      <pre>
form.addEventListener('submit', (e) => {
  e.preventDefault();
})</pre>
    </dd>
    <dd>.或</dd>
    <dd>
      <pre>
form.addEventListener('submit', (e) => {
  return false;
})</pre>
    </dd>
    <dd class="mt2">[<span class="iconfont icon-keyboard"></span>] 阻止&lt;a&gt;默认跳转</dd>
    <dd>
      <pre>
a.addEventListener('click', (e) => {
  e.preventDefault();
})</pre>
    </dd>
    <dd>.简单粗暴型的，直接在结构上拍死</dd>
    <dd>
      <pre>&lt;a href="javascript:;"&gt;link&lt;/a&gt;</pre>
    </dd>
  </dl>
  <iframe src="../../common/footer.html" frameborder="0" scrolling="no" title="footer" id="footer"></iframe>
  <script src="../js/mouse.js"></script>
  <script src="../lib/ham.js"></script>
  <script>
    let form = document.querySelector('form')
    let formData = new FormData(form)
    console.log(form);
    console.log(formData);
    // form.addEventListener('submit', e => {
    //   e.preventDefault()
    //   console.log(e);
    // })
  </script>
</body>

</html>