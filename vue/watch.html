<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>侦听器 Watch</title>
    <link rel="stylesheet" href="../css/reset2024.css">
    <link rel="stylesheet" href="../css/common2024.css">
    <link rel="stylesheet" href="../css/code.css">
    <link rel="stylesheet" href="../css/sn.css">
    <base target="_blank">
</head>

<body>
    <header>
        <h1>侦听器</h1>
        <span>Watch</span>
    </header>
    <dl>
        <dd>监听响应式数据源；当数据源发送变化时，在回调函数中处理响应的逻辑</dd>
        <dd>使用 watch 函数在每次响应式状态发生变化时触发回调函数</dd>
        <dd>侦听的是响应式数据，不能直接侦听响应式数据的属性</dd>
        <dd>更多信息，请访问<a href="https://cn.vuejs.org/api/reactivity-core.html#watch" class="link">watch()</a></dd>
        <dd>需引入包 watch</dd>
        <dd>
            <pre>import { watch } from 'vue'</pre>
        </dd>
        <dt>参数</dt>
        <dd>三个：数据源source、回调函数cb、配置项options</dd>
        <dd class="bg">1. 数据源 source</dd>
        <dd>侦听数据类型 - 4种</dd>
        <dd>. 一个 ref 对象 (包括计算属性)</dd>
        <dd>. 一个 reactive 对象</dd>
        <dd>. 一个 getter 函数：一个有返回的函数</dd>
        <dd>. 多个响应式数据源组成的数组</dd>
        <dd class="bg">2. 回调函数 cb</dd>
        <dd>侦听时，回调函数会使用2个参数来区分新值newValue和旧值oldValue</dd>
        <dd>通常我们只关心新值newValue，即：一个参数就够了</dd>
        <dd>若侦听的是ref对象的属性，则新值旧值一样，是同一个对象</dd>
        <dd>若侦听的是ref对象，则新值是新对象，旧值是老对象，不是同一个对象</dd>
        <dd class="bg">3. 配置项 options</dd>
        <dd>3.1 立即侦听 immediate</dd>
        <dd>watch默认是懒执行的：仅当数据源变化时，才会执行回调</dd>
        <dd>有时，需要在源变化之前就开始执行回调，如购物车总价，每次变化前都先结算一次</dd>
        <dd>这个时新值是当前值，而旧值未定义；同初恋一样，无前任</dd>
        <dd>设置配置项immediate为true</dd>
        <dd>3.2 深度侦听 deep</dd>
        <dd>默认情况下，只侦听响应式对象，不能侦听对象的属性</dd>
        <dd>侦听复合对象内部属性时，需要开启深度侦听：设置deep为true</dd>
        <dd>侦听reactive对象时，默认开启deep，且无法关闭</dd>
        <dd>深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请只在必要时才使用它，并且要留意性能</dd>
    </dl>
    <div class="chap">侦听 ref</div>
    <dl>
        <dt>侦听 ref - 一个简单数据</dt>
        <dd>当单击执行增加函数inc时，Vue可以检测到num的变化，从而做出反应；如商品数量增加或减少时，总价发现变化</dd>
        <dd>
            <pre>
let num = ref(0)
const inc = () =>{
    num.value++
}
watch(num, (newv, oldv) => {
    console.log('num old vs new', oldv, newv);
})</pre>
        </dd>
        <dd>如果侦听num.value，则会提示</dd>
        <dd>
            <pre>Invalid watch source:  0 A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.at ... </pre>
        </dd>
        <dt>侦听 ref - 多个简单数据</dt>
        <dd><span class="warn">任何</span>一个对象发生变化都会被监听到；是或的关系，不是与的关系</dd>
        <dd>以数组的形式 <span class="warn">分别</span> 表示多个数据源：1个数据源变成多个数据源</dd>
        <dd>以数组的形式 <span class="warn">分别</span> 显示新值和旧值：1个新值变成多个新值；一个旧值变成多个旧值</dd>
        <dd>信用卡年费免除：消费达到一定金额(10000)或消费多少次(6)，免除当年年费</dd>
        <dd>
            <pre>
let times = ref(0)
let sum = ref(0)
function incTimes() {
    times.value++
}
function incSum() {
    sum.value += 1000
}
watch([times, sum], ([new1, new2], [old1, old2]) => {
    console.log(old1, new1, old2, new2);
})</pre>
        </dd>
        <dt>侦听 ref - 复合数据</dt>
        <dd>侦听复合数据，需开启深度侦听：设置deep为true</dd>
        <dd>任一属性变化都会被Vue捕获；但是变化前后都是同一个对象；所以newv和oldv是一样的，其内部的属性也是一样的</dd>
        <dd>结论：仅仅知道数据属性发生变化，无法获知前后变化情况</dd>
        <dd>
            <pre>
let user = ref({
    id: 100,
    name: 'glpla',
    age: 18,
    addr: {
        city: 'cq',
        code: '541000'
    }
})
watch(user, (newv, oldv) => {
    console.log('user is watched', newv.age, oldv.age);
}, { deep: true })</pre>
        </dd>
        <dt>深度侦听- 侦听复合 ref 某个指定属性</dt>
        <dd>仅仅当该属性变化时才触发回调</dd>
        <dd>利用函数获取侦听属性 - <span class="warn">注意</span> 官文没有使用value！！！</dd>
        <dd>无需开启deep</dd>
        <dd>age变化时，触发侦听；code变化时，不触发</dd>
        <dd>
            <pre>
watch(() => user.value.age, (n, o) => {
    console.log(o, n);
})</pre>
        </dd>
    </dl>
    <div class="chap">侦听 reactive</div>
    <dl>
        <dt>侦听 reactive - 属性变化</dt>
        <dd>侦听的是对象某个属性的变化；当某个属性变化时，会被Vue捕获</dd>
        <dd>新值旧值是reactive对象，变化前后都是同一个对象；所以newv和oldv是一样的，其内部的属性也是一样的</dd>
        <dd>体会对象的引用特性</dd>
        <dd>结论：可以捕获到数据属性变化，但是无法查看属性前后的变化</dd>
        <dd>
            <pre>
let user = reactive({
    id: 100,
    name: 'glpla',
    age: 18,
    addr: {
        city: 'cq',
        code: '541000'
    }
})    
watch(user, (newv, oldv) => {
    console.log('user is watched', newv, oldv);
    console.log('user is watched', newv.age, oldv.age);
})
const incAge = () => {
    user.age++
}</pre>
        </dd>
        <dt>侦听 reactive - 捕获属性前后变化</dt>
        <dd>利用函数获取侦听的属性 - 简单属性</dd>
        <dd>
            <pre>
watch(() => user.age, (newv, oldv) => {
    console.log(oldv, newv);
})
</pre>
        </dd>
        <dd>利用函数获取侦听的属性 - 复合属性</dd>
        <dd>
            <pre>
watch(() => user.addr.code, (n, o) => {
    console.log(o, n);
})</pre>
        </dd>
        <dt>侦听 reactive - 多个属性变化</dt>
        <dd>
            <pre>
watch([() => user.age, () => user.addr.code], ([n0, n1], [o0, o1]) => {
    console.log(o0, n0, o1, n1);
})</pre>
        </dd>
    </dl>
    <div class="chap">立即侦听</div>
    <dl>
        <dd>设置配置项immediate为true；其它使用同上</dd>
    </dl>
    <div class="chap">停止侦听器</div>
    <dl>
        <dd>
            <pre>
const stop = watch(source, callback)

// 当已不再需要该侦听器时：
stop()</pre>
        </dd>
    </dl>
    <dl>
        <dd class="example-sn">分析下面代码的功能</dd>
        <dd>
            <pre>
watch(msg, (newv, oldv) => {
    str.value = newv.split('').reverse().join('')
})</pre>
        </dd>
        <dd class="example-sn">购物车</dd>
        <dd>侦听购物车商品的总价</dd>
        <dd>侦听购物车商品的全选</dd>
    </dl>
    <iframe src="../common/footer.html" frameborder="0" scrolling="no" title="footer" id="footer"></iframe>
</body>

</html>