<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>侦听器 Watch vs WatchEffect</title>
    <link rel="stylesheet" href="../css/reset2024.css">
    <link rel="stylesheet" href="../css/common2024.css">
    <link rel="stylesheet" href="../css/code.css">
    <link rel="stylesheet" href="../css/sn.css">
    <base target="_blank">
</head>

<body>
    <header>
        <h1>侦听器</h1>
        <span>Watch vs WatchEffect</span>
    </header>
    <div class="chap">watch</div>
    <dl>
        <dd>使用 watch 函数在每次响应式状态发生变化时触发回调函数</dd>
        <dd>需引入包 watch</dd>
        <dd>三个参数：数据源、回调函数、配置项</dd>
        <dt>数据源</dt>
        <dd>可以侦听数据类型 - 4种</dd>
        <dd>. ref 对象 (包括计算属性)：侦听对象的变化，不是值的变化</dd>
        <dd>. reactive 对象</dd>
        <dd>. getter 函数：一个有返回的函数</dd>
        <dd>. 多个响应式数据源组成的数组</dd>
        <dd class="example-sn">侦听 ref - 仅当ref变化时才会侦听，不是ref的值</dd>
        <dd>
            <figure class="code">
                <figcaption>侦听简单 ref</figcaption>
                <pre>
let num = ref(0)
watch(num, (newv, oldv) => {
    console.log('num is watched', newv, oldv);
})
function numCh() {
    num.value++
}</pre>
            </figure>
            <figure class="code">
                <figcaption>侦听复合 ref</figcaption>
                <pre>
let num = ref({num: 0})
watch(num, (newv, oldv) => {
    console.log('num is watched', newv, oldv);
})
function numCh() {
    num.value = { count: 10 }   //侦听有效
}
function numChCount() {
    num.value.count++   //侦听无效
}</pre>
            </figure>
        </dd>
        <dd class="example-sn">侦听reactive - 侦听的是对象属性的变化，默认开启deep</dd>
        <dd class="code">
            <pre>
let num = reactive({ count: 0 })
watch(num, (newv, oldv) => {
    console.log('num is watched', newv, oldv);
})
function numChCount() {
    num.count++
},
{deep: false}   //无法关闭</pre>
        </dd>
        <dd class="example-sn">使用函数 - 侦听reactive单个属性</dd>
        <dd>默认是对象或对象任何一个属性变化时，都会触发回调函数，如果只想侦听某一个属性，就需要使用函数</dd>
        <dd>
            <figure class="code">
                <figcaption>属性是简单数据类型 - 侦听age变化</figcaption>
                <pre>
let person = reactive({
    name: 'glpla',
    age: 18,
    addr: {
        city: 'cq',
        code: '541000'
    }
})
watch(() => { return person.age }, (newv, oldv) => {
  console.log('person.age is watched', newv, oldv);
})</pre>
            </figure>
        </dd>
        <dd>
            <figure class="code">
                <figcaption>属性是复合数据类型 - 侦听addr变化</figcaption>
                <pre>
let person = reactive({
    name: 'glpla',
    age: 18,
    addr: {
        city: 'cq',
        code: '541000'
    }
})
watch(() => { return person.addr }, (newv, oldv) => {
    console.log('person.addr is watched', newv, oldv);
})</pre>
            </figure>
        </dd>
        <dd class="example-sn">侦听多个数据</dd>
        <dd>以数组的形式，分别使用对象或函数</dd>
        <dd>
            <figure class="code">
                <figcaption>ref对象 - 侦听name和age</figcaption>
                <pre>
let name = ref('gl')
let age = ref(0)
watch([ name, age ], (newv, oldv) => {
    console.log('name or age is watched', newv, oldv);
})</pre>
            </figure>
            <figure class="code">
                <figcaption>reactive对象 - 侦听age和addr</figcaption>
                <pre>
let person = reactive({
    name: 'glpla',
    age: 18,
    addr: {
        city: 'cq',
        code: '541000'
    }
})
watch([ () => { return person.age }, () => { return person.addr } ], (newv, oldv) => {
    console.log('person.age or person.addr is watched', newv, oldv);
})</pre>
            </figure>
        </dd>
        <dd class="tips">如果侦听的数据非常多呢？？？</dd>
        <dt>回调函数</dt>
        <dd>侦听时，回调函数会使用2个参数来区分新值newValue和旧值oldValue</dd>
        <dd>通常我们只关心新值newValue，即：一个参数就够了</dd>
        <dd>若侦听的是ref对象的属性，则新值旧值一样，是同一个对象</dd>
        <dd>若侦听的是ref对象，则新值是新对象，旧值是老对象，不是同一个对象</dd>
        <dt>配置项</dt>
        <dd>1. 深度侦听 deep</dd>
        <dd>侦听复合对象内部属性时，需要开启深度侦听</dd>
        <dd>侦听reactive对象时，默认开启deep，且无法关闭</dd>
        <dd>
            <figure class="code">
                <figcaption>侦听复合 ref 的属性</figcaption>
                <pre>
import { ref, watch } from 'vue'
let num = ref({ count: 0 })
watch(num, (newv, oldv) => {
  console.log('num is watched', newv, oldv);
}, { deep: true })</pre>
            </figure>
        </dd>
        <dd>2. 立即侦听 immediate</dd>
        <dd>watch默认是懒执行的：仅当数据源变化时，才会执行回调</dd>
        <dd>有时，需要在源变化之前就开始执行回调，如同定时器的先执行1次一样</dd>
        <dd>这个时新值是当前值，而旧值未定义；同初恋一样，无前任</dd>
        <dd class="code">
            <pre>
watch(
  source,
  (newValue, oldValue) => {
    // 立即执行，且当 `source` 改变时再次执行
  }, { immediate: true }
)</pre>
        </dd>
        <dd>3. 其它</dd>
    </dl>
    <div class="chap">WatchEffect</div>
    <dl>
        <dd>需引入包 watchEffect</dd>
        <dd>watch 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。watch 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机
        </dd>
        <dd>watchEffect，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确</dd>
        <dd>watchEffect会立即执行回调函数，等同于使用了立即配置项immediate</dd>
        <dd class="example-sn">使用watchEffect自动侦听多个数据</dd>
        <dd>
            <figure class="code">
                <figcaption>ref对象 - 自动侦听name和age</figcaption>
                <pre>
let temp = ref(0)
let hei = ref(0)
watchEffect(() => {
    if (temp.value > 10 || hei.value > 20) {
    console.log('data is meet');
    }
})
function tempCh() {
    temp.value += 2
}
function heiCh() {
    hei.value += 2
}</pre>
            </figure>
        </dd>
        <dt>停止侦听</dt>
        <dd>要手动停止一个侦听器，请调用 watch 或 watchEffect 返回的函数</dd>
        <dd class="example-sn">停止侦听</dd>
        <dd class="code">
            <pre>
const stopWatch = watch(num, (newv, oldv) => {
    console.log('num is watched', newv, oldv);
    if(newv > 5){
        stopWatch()
    }
})</pre>
        </dd>
    </dl>
    <iframe src="../common/footer.html" frameborder="0" scrolling="no" title="footer" id="footer"></iframe>
</body>

</html>