<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>状态管理 Pinia</title>
    <link rel="stylesheet" href="../css/common.css">
    <base target="_blank">
    <style>
        header {
            background-image:
                url(https://pinia.vuejs.org/logo.svg),
                linear-gradient(315deg, var(--color) 25%, var(--color-dark));
            background-repeat: no-repeat;
            background-size: 10vh, 100%;
            background-position: right 90px bottom -10px, 0 0;
        }
    </style>
</head>

<body>
    <header>
        <h1>状态管理</h1>
        <span>&commat; Pinia</span>
    </header>
    <dl>
        <dt>仓库 Store</dt>
        <dd>是一个保存全局状态 <span class="warn">state</span> 和业务逻辑的实体；可以在 <span class="warn">整个应用</span> 中访问的数据</dd>
        <dd>不与组件树绑定，而承载着全局状态</dd>
        <dd>仓库通常集中保存在项目的 stores 目录（应提前创建好），并按照功能创建 <span class="warn">单独</span> 的仓库文件</dd>
        <dd>仓库在 onMounted 之前就已经准备好 - 兵马未动，粮草先行</dd>
        <dd>利用仓库 store 集中式状态管理：抽取出组件间的共享状态，放在一个全局单例中来管理</dd>
        <dd>状态管理出现之前，使用共享组件完成对共享数据的使用；共享数据的修改通过共享组件发送自定义事件完成。这就意味着：任何一个使用它的组件都可以修改，不太容易维护；注意：共享数据和全局数据不是一回事</dd>
        <dd>Vue3采用 <a href="https://pinia.vuejs.org/zh/" class="link">Pinia</a>；Pinia 是 Vue
            的专属状态管理库，使用大菠萝作为 logo</dd>
        <dd>Vue2采用 vuex</dd>
        <dt>核心概念 Concepts</dt>
        <dd class="sn">
            <div>State - 驱动整个应用的数据源；是 store 的核心。应先定义能代表应用或反映应用状态的 state；相当于组件中的 data</div>
            <div>Getter - 对状态的一种声明式映射；相当于组件中的 computed</div>
            <div>Action - 根据用户的交互对数据源的操作；相当于组件中的 method</div>
        </dd>
        <dd>
            <figure class="img-sn">
                <img src="./imgs/pinia0.png" alt="">
                <figcaption>关系</figcaption>
            </figure>
        </dd>
        <dt>安装 Installation</dt>
        <dd>可以在创建项目的时，选择状态管理；项目创建完毕后，可以直接使用 - 强烈建议</dd>
        <dd>也可以单独安装，需要引入、配置等；不建议新手使用</dd>
        <dd>
            <pre>npm i pinia --save</pre>
        </dd>
        <dt>引入 Import</dt>
        <dd>在入口文件 main.js 引入并创建使用</dd>
        <dd>完成后，在开发者工具中可以看到大菠萝</dd>
        <dd>在 main.js 中引入并使用</dd>
        <dd>
            <pre>
import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'
//1. 导入
import { createPinia } from 'pinia'
//2. 创建
const pinia = createPinia()
const app = createApp(App)
//3. 使用
app.use(pinia)
app.mount('#app')</pre>
        </dd>
        <!-- <dd class="tips">
            <div>仓库会自动处理数据的响应式。通常不需要使用 ref 或 reactive 来声明状态；但是调试的时候，数据最初不会更新</div>
            <div>即使指定了ref()，后期维护的时候，也不能带上.value</div>
            <div>仅仅在精细化操作的时候，需要指定；如：使用计算属性等</div>
            <div>为了和开发保持一致和调试方便，建议尽量指定响应式</div>
        </dd> -->
        <dd class="tips">如果创建项目时，指定了状态管理，就不需要上面的安装和配置，可以直接创建仓库使用</dd>
        <dt>基本步骤 Steps</dt>
        <dd>更多信息，请访问 <a href="https://pinia.vuejs.org/zh/core-concepts/#setup-stores">Pinia -
                setup-stores</a></dd>
        <dd class="sn">
            <div>创建仓库文件 .js，使用语义化命名，如counter.js</div>
            <div>引入 defineStore 库及其它必要库</div>
            <div>使用 defineStore 创建仓库实例，其中：</div>
            <p>. 第一个参数 counter 是你的应用中 Store 的唯一 ID，Pinia 将用它来连接 store 和 devtools</p>
            <p>. 第二个参数接收 option 对象或 setup 函数；setup 函数和组合式 API 类似，且功能更灵活</p>
            <div>导出仓库示例，以 use 开头且以 Store 结尾命名，如useCounterStore</div>
            <pre>
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export const useCounterStore  = defineStore('counter', ()=>{
  //state - ref()
  const count = ref(0)
  const msg = ref('hi,there.')
  
  //getters - computed()
  const doubleCount = computed( () => count.value * 2 )
  
  //action - function()
  const increment = () => count.value++

  return { count, msg, doubleCount, increment }
})</pre>
            <div>目标组件使用 Store</div>
            <p>逻辑 - 引入仓库、创建仓库实例、使用仓库数据；<span class="warn">创建仓库实例前无法使用</span></p>
            <pre>
&lt;script setup&gt;
    import { useCounterStore } from '@/stores/counter';
    const store = useCounterStore();
    console.log('store', store);
&lt;/script&gt;</pre>
            <p>结构 - 渲染仓库数据；这里采用内联事件</p>
            <pre>
&lt;template&gt;
    &lt;div&gt;{{ store.count }}&lt;/div&gt;
    &lt;div&gt;{{ store.msg }}&lt;/div&gt;
    &lt;div&gt;{{ store.doubleCount }}&lt;/div&gt;
    &lt;div @click="store.increment"&gt;store handle&lt;/div&gt;
&lt;/template&gt;</pre>
        </dd>
        <dd>直接解构使用store中的数据(方法)会丢失响应：当仓库状态变化时，count不变，相当于是获取了仓库的一次性数据</dd>
        <dd>
            <pre>let { count, increment } = counterStore;</pre>
        </dd>
        <dd>
            <pre>&lt;div&gt;仓库数据 - {{ store.count }} - {{ count }}&lt;/div&gt;</pre>
        </dd>
        <dd>使用storeToRefs包保持响应式 - 不建议；<span class="warn">命名冲突。。。可读性不好。。。运维困难。。。</span></dd>
        <dd>
            <pre>
import { storeToRefs } from 'pinia';
let { count, increment } = storeToRefs(counterStore);</pre>
        </dd>
        <dd class="example-sn"><a href="./pro_lists.html">项目 - 商品列表</a></dd>
        <dd class="sn">
            <div>创建仓库 - 商品 goods、状态 isLoading、请求 fetchGoods</div>
            <div>请求商品数据 - 分别使用 fetch 和 axios</div>
            <div>请求中，给出提示；请求结束，渲染数据</div>
            <div>使用条件渲染追踪过程</div>
            <pre>
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
export const useGoodStore = defineStore('good', () => {
  const goods = ref([])
  const isLoading = ref(false)
  const fetchGoods = async () => {
    isLoading.value = true
    let res = await fetch('http://127.0.0.1:3000/goods')
    let data = await res.json()
    goods.value = data
    isLoading.value = false
  }
  return { goods, isLoading, fetchGoods, }
})</pre>
            <pre>
import { onMounted } from 'vue';
import { useGoodStore } from '@/stores/good';
const store = useGoodStore();
onMounted(() => {
  store.fetchGoods();
})</pre>
            <pre>
&lt;div v-if="store.isLoading"&gt;    loading    &lt;/div&gt;
&lt;div v-else&gt;
    //
&lt;/div&gt;</pre>
            <p class="tips">在开发者视图中，使用慢速网络查看状态变化</p>
        </dd>
        <dd class="example-sn"><a href="./drill_cart_pinia.html">实操 - 购物车优化</a></dd>
        <dd>使用仓库并更新仓库</dd>
        <dd class="example-sn">定义导航菜单仓库，详情请查看 <a href="./drill_menu.html">实操 - 汉堡菜单</a></dd>
        <dd>项目从桌面端切换到移动端时，菜单折叠，由汉堡按钮控制折叠和展开；单击菜单项时，折叠菜单</dd>
        <dd>1. 创建仓库 - 仓库参考代码 menu.js</dd>
        <dd>
            <pre>
import { ref } from 'vue'
import { defineStore } from 'pinia'

export const useMenuStore = defineStore('menu', () => {
  const flag = ref(false)
  const switchFlag = () => {
    flag.value ? flag.value = false : flag.value = true
  }

  return { flag, switchFlag }
})</pre>
        </dd>
        <dd>2. 在使用仓库的组件结构中，引入仓库，通过汉堡按钮的单击，由标记 flag 控制动态类的应用，达到菜单的折叠和展开</dd>
        <dd>改进：单击菜单项，折叠菜单</dd>
        <dd>提示：在路由配置中，引入仓库，在导航前置守卫中实例化仓库并切换标记switchFlag；请查看 <a href="./router5.html">路由 - 导航守卫</a></dd>
    </dl>
    <div class="chap">更多仓库操作*</div>
    <dl>
        <dd>具体信息，请访问 <a href="https://pinia.vuejs.org/zh/core-concepts/state.html">Pinia - State</a></dd>
        <dt>访问 state</dt>
        <dd>
            <div> 默认情况下，通过 仓库实例 访问 state，直接对其进行读写</div>
            <pre>
const store = useStore()
store.count++</pre>
        </dd>
        <dt>重置 state</dt>
        <dd>
            <div>Setup Stores，需创建自己的 $reset()，手动还原</div>
            <div>选项式 API，通过调用 store 的 $reset() 方法将 state 重置为初始值；简单粗暴</div>
            <div class="warn">谨慎！！！</div>
            <pre>
export const useCounterStore = defineStore('counter', () => {
    const count = ref(0)
    
    const  $reset = () => {
        count.value = 0
    }
    
    return { count, $reset }
})</pre>
        </dd>
        <dt>变更 state</dt>
        <dd>
            <div>除了单独变更某个state外，还可以使用 patch ；且在同一时间更改多个属性</div>
            <pre>
store.$patch({
    count: store.count + 1,
    age: 120,
    name: 'DIO',
})</pre>
        </dd>
        <dt>替换 state</dt>
        <dd>
            <div>直接赋值修改并不能完全替换掉 store 的 state，因为那样会破坏其响应性</div>
            <pre>store.$state = { count: 24 }</pre>
            <div>但是，你可以使用 patch ；且在同一时间更改多个属性</div>
            <pre>store.$patch({ count: 24, msg: 'hi,there.' })</pre>
            <div>或使用参数</div>
            <pre>
store.$patch((state) => {
    state.count = 1000;
    state.msg = 'hi';
});</pre>
        </dd>
        <dt>订阅 state</dt>
        <dd>
            <div>通过 store 的 $subscribe() 方法侦听 state 及其变化。比起普通的 watch()，使用 $subscribe() 的好处是 subscriptions 在
                patch 后只触发一次</div>
            <div>可以在 pinia 实例上使用 watch() 函数侦听整个 state</div>
        </dd>
        <dd class="tips">什么时候使用 Store?</dd>
    </dl>
    <iframe src="../common/footer.html" frameborder="0" scrolling="no" title="footer" id="footer"></iframe>
    <script src="../utils/custom/clipboard.js"></script>
</body>

</html>